<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Real-World Dimension Estimator (Single-View)</title>
<style>
  :root { --card:#fff; --muted:#666; --border:#dcdcdc; }
  body { font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:24px; background:#fafafa; }
  h1 { font-size:1.25rem; margin-bottom:8px; }
  .row { display:flex; flex-wrap:wrap; gap:16px; }
  .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; }
  .small { font-size:12px; color:var(--muted); }
  input, button { padding:6px 10px; margin:4px 2px; border-radius:8px; border:1px solid var(--border); background:#fff; }
  button:hover { background:#f2f2f2; cursor:pointer; }
  canvas, video { max-width:100%; border:1px solid var(--border); border-radius:12px; background:#fff; }
  #result { font-weight:600; margin-top:8px; }
  #hud { display:flex; gap:8px; align-items:center; }
  #lens { width:160px; height:160px; border:2px solid var(--border); border-radius:12px; background:#fff; image-rendering:pixelated; }
  pre { margin:0; }
</style>
</head>
<body>
<h1>Real-World Dimension Estimator (Single-View)</h1>
<div class="row">
  <div class="card">
    <div><b>1) Load image or start camera</b></div>
    <input id="file" type="file" accept="image/*"><br/>
    <button id="startCam">Start Camera</button>
    <button id="stopCam">Stop Camera</button>
    <div class="small">Note: webcam requires HTTPS on the web; it works on <code>localhost</code>.</div>
    <video id="video" autoplay playsinline style="display:none;"></video>
  </div>

  <div class="card">
    <div><b>2) Enter known distance Z (meters)</b></div>
    <input id="Z" type="number" step="0.001" placeholder="e.g., 0.6858"/>
    <div><b>3) Click two points to measure</b></div>
    <div id="hud">
      <button id="reset">Reset</button>
      <button id="export">Save PNG</button>
      <span class="small">Tip: hover to use the zoom lens.</span>
    </div>
    <div id="result">Load an image or start camera, enter Z, click two points.</div>
  </div>

  <div class="card">
    <div><b>Calibration (from your camera)</b></div>
    <pre id="kdisp"></pre>
  </div>
</div>

<div class="row" style="margin-top:12px;">
  <div class="card">
    <canvas id="canvas"></canvas>
  </div>
  <div class="card">
    <canvas id="lens" width="160" height="160"></canvas>
    <div class="small">Zoom lens (10×) centered on cursor for precise clicks.</div>
  </div>
</div>

<script>
// ---- Your fixed calibration (from earlier) ----
const fx = 3.02872766e3;
const fy = 3.02473159e3;
const cx = 1.54361101e3;
const cy = 1.98367915e3;
const f  = (fx + fy) / 2.0;
const dist = [0.238754261, -1.71450036, -0.0000714927, -0.0009264364, 3.06366683];

document.getElementById('kdisp').textContent =
`fx=${fx.toFixed(2)}  fy=${fy.toFixed(2)}  cx=${cx.toFixed(2)}  cy=${cy.toFixed(2)}
dist=[${dist.map(v=>v.toFixed(6)).join(', ')}]
Using f=${f.toFixed(2)} px in L = (d_px * Z) / f`;

const file   = document.getElementById('file');
const video  = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx    = canvas.getContext('2d');
const ZEl    = document.getElementById('Z');
const resetB = document.getElementById('reset');
const exportB= document.getElementById('export');
const startB = document.getElementById('startCam');
const stopB  = document.getElementById('stopCam');
const result = document.getElementById('result');

const lens   = document.getElementById('lens');
const lctx   = lens.getContext('2d');

let stream = null;
let img = new Image();
let pts = [];

function drawFrame() {
  if (video.style.display !== 'none' && stream) {
    if (video.videoWidth === 0) { requestAnimationFrame(drawFrame); return; }
    canvas.width  = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0);
  } else if (img.complete && img.naturalWidth > 0) {
    canvas.width  = img.naturalWidth;
    canvas.height = img.naturalHeight;
    ctx.drawImage(img, 0, 0);
  } else {
    return;
  }

  // points & line
  ctx.fillStyle = 'lime';
  pts.forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, 2*Math.PI); ctx.fill(); });
  if (pts.length === 2) {
    ctx.strokeStyle = 'red'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y);
    ctx.lineTo(pts[1].x, pts[1].y); ctx.stroke();

    const dpx = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
    const Z = parseFloat(ZEl.value);
    if (isFinite(Z) && Z > 0) {
      const Lm = (dpx * Z) / f, Lmm = Lm * 1000;
      result.textContent = `d_px=${dpx.toFixed(2)} px → Length ≈ ${Lmm.toFixed(2)} mm (Z=${Z.toFixed(3)} m)`;
      // overlay label
      ctx.fillStyle = 'rgba(255,255,255,0.85)';
      ctx.fillRect(10,10,360,30);
      ctx.fillStyle = '#000';
      ctx.font = '16px system-ui';
      ctx.fillText(`Length ≈ ${Lmm.toFixed(2)} mm`, 18, 30);
    } else {
      result.textContent = 'Enter Z (meters) to compute length.';
    }
  } else {
    result.textContent = 'Click two points to measure. Press "Reset" to try again.';
  }
}

function loop(){ drawFrame(); requestAnimationFrame(loop); }
loop();

// image load
file.addEventListener('change', e => {
  const f = e.target.files[0];
  if (!f) return;
  stopCamera();
  img.onload = () => drawFrame();
  img.src = URL.createObjectURL(f);
});

// camera
async function startCamera(){
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
    video.srcObject = stream;
    video.style.display = 'block';
  } catch (err) {
    alert('Camera error: ' + err.message);
  }
}
function stopCamera(){
  if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
  video.style.display = 'none';
}
startB.onclick = startCamera;
stopB.onclick  = stopCamera;

// clicks
canvas.addEventListener('click', e => {
  const r = canvas.getBoundingClientRect();
  const x = (e.clientX - r.left) * (canvas.width / r.width);
  const y = (e.clientY - r.top)  * (canvas.height / r.height);
  if (pts.length >= 2) pts = [];
  pts.push({x, y});
});

// zoom lens under cursor (10×)
canvas.addEventListener('mousemove', e => {
  if (canvas.width === 0) return;
  const r = canvas.getBoundingClientRect();
  const x = (e.clientX - r.left) * (canvas.width / r.width);
  const y = (e.clientY - r.top)  * (canvas.height / r.height);

  const zoom = 10;               // magnification
  const box  = 16;               // half-size of source box (px)
  const sx   = Math.max(0, Math.min(canvas.width  - 2*box, Math.round(x - box)));
  const sy   = Math.max(0, Math.min(canvas.height - 2*box, Math.round(y - box)));

  lctx.imageSmoothingEnabled = false;
  lctx.clearRect(0,0,lens.width,lens.height);
  lctx.drawImage(canvas, sx, sy, 2*box, 2*box, 0, 0, lens.width, lens.height);
  // crosshair
  lctx.strokeStyle = 'rgba(0,0,0,0.6)';
  lctx.beginPath();
  lctx.moveTo(lens.width/2, 0);          lctx.lineTo(lens.width/2, lens.height);
  lctx.moveTo(0, lens.height/2);         lctx.lineTo(lens.width, lens.height/2);
  lctx.stroke();
});

resetB.onclick = () => { pts = []; result.textContent = 'Reset. Click two points to measure.'; };
exportB.onclick = () => {
  const a = document.createElement('a');
  a.download = 'measurement.png';
  a.href = canvas.toDataURL('image/png');
  a.click();
};
</script>
</body>
</html>
